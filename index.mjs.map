{"version":3,"file":"index.mjs","sources":["node_modules/@webreflection/signal/esm/index.js","node_modules/udomdiff/esm/index.js","node_modules/uhtml/esm/utils.js","node_modules/domconstants/esm/constants.js","node_modules/custom-function/esm/factory.js","node_modules/uhtml/esm/range.js","node_modules/uhtml/esm/persistent-fragment.js","node_modules/uhtml/esm/handler.js","node_modules/uhtml/esm/literals.js","node_modules/uhtml/esm/creator.js","node_modules/domconstants/esm/re.js","node_modules/@webreflection/uparser/esm/index.js","node_modules/uhtml/esm/create-content.js","node_modules/uhtml/esm/parser.js","node_modules/uhtml/esm/rabbit.js","node_modules/uhtml/esm/index.js","node_modules/uhtml/esm/render/shared.js","node_modules/gc-hook/esm/index.js","node_modules/uhtml/esm/render/reactive.js","KartonElement.js"],"sourcesContent":["/*! (c) Andrea Giammarchi */\n\nlet batches = null;\n\n/**\n * Invoke a callback that updates many signals and runs effects only after.\n * @type {(fn:() => void) => void}\n */\nexport const batch = fn => {\n  let effects = batches;\n  if (!effects) batches = new Set;\n  try { fn() }\n  finally {\n    if (!effects) {\n      [batches, effects] = [null, batches];\n      for (const effect of effects) effect._();\n    }\n  }\n};\n\nconst cleared = self => {\n  const entries = [...self];\n  self.clear();\n  return entries;\n};\n\nclass Effect extends Set {\n  constructor(_) { super()._ = _ }\n  dispose() {\n    for (const entry of cleared(this)) {\n      entry.delete(this);\n      entry.dispose?.();\n    }\n  }\n}\n\nlet current = null;\nconst create = (block) => {\n  const fx = new Effect(() => {\n    const prev = current;\n    current = fx;\n    try { block() }\n    finally { current = prev }\n  });\n  return fx;\n};\n\n/**\n * Invokes a function when any of its internal signals or computed values change.\n * Returns a `dispose` callback.\n * @template T\n * @type {<T>(fn: (v?: T) => T | undefined, value?: T) => () => void}\n */\nexport const effect = (fn) => {\n  let teardown, fx = create(() => { teardown?.call?.(); teardown = fn() });\n  if (current) current.add(fx);\n  return fx._(), () => (teardown?.call?.(), fx.dispose());\n};\n\n/**\n * Executes a given function without tracking its dependencies.\n * This is useful for actions that should not subscribe to updates in the reactive system.\n * @param {Function} fn - The function to execute without dependency tracking.\n */\nexport const untracked = (fn) => {\n  let prev = current, result\n  current = null\n  result = fn()\n  current = prev\n  return result\n}\n\n/**\n * A signal with a value property also exposed via toJSON, toString and valueOf.\n * @template T\n */\nexport class Signal extends Set {\n\n  /** @param {T} value the value carried through the signal */\n  constructor(_) { super()._ = _ }\n\n  /** @returns {T} */\n  get value() {\n    if (current) current.add(this.add(current));\n    return this._;\n  }\n\n  /** @param {T} value the new value carried through the signal */\n  set value(_) {\n    if (this._ !== _) {\n      this._ = _;\n      const root = !batches;\n      for (const effect of cleared(this)) {\n        if (root) effect._();\n        else batches.add(effect);\n      }\n    }\n  }\n\n  // EXPLICIT NO SIDE EFFECT\n  peek() { return this._ }\n\n  // IMPLICIT SIDE EFFECT\n  toJSON() { return this.value }\n  valueOf() { return this.value }\n  toString() { return String(this.value) }\n}\n\n/**\n * Returns a writable Signal that side-effects whenever its value gets updated.\n * @template T\n * @type {<T>(value: T) => Signal<T>}\n */\nexport const signal = value => new Signal(value);\n\n/**\n * A read-only Signal extend that is invoked only when any of the internally\n * used signals, as in within the callback, is unknown or updated.\n * @template T\n * @extends {Signal<T>}\n */\nexport class Computed extends Signal {\n  /**\n   * @param {(v?: T) => T} fn the callback invoked when its signals changes\n   * @param {T | undefined} value the optional initial value of the callback\n   */\n  constructor(fn, value) {\n    super(value).f = fn;\n    this.e = null;\n  }\n\n  /** @readonly @returns {T} */\n  get value() {\n    if (!this.e)\n      (this.e = create(() => { super.value = this.f(this._) }))._();\n    return super.value;\n  }\n\n  /** @throws {Error} */\n  set value(_) { throw new Error('computed is read-only') }\n}\n\n/**\n * Returns a Computed signal that is invoked only when any of the internally\n * used signals, as in within the callback, is unknown or updated.\n * @template T\n * @type {<T>(fn: (v?: T) => T, value?: T) => Computed<T>}\n */\nexport const computed = (fn, value) => new Computed(fn, value);\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -0).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -0).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","const { isArray } = Array;\nconst { getPrototypeOf, getOwnPropertyDescriptor } = Object;\n\nexport { isArray };\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const empty = [];\n\nexport const newRange = () => document.createRange();\n\n/**\n * Set the `key` `value` pair to the *Map* or *WeakMap* and returns the `value`\n * @template T\n * @param {Map | WeakMap} map\n * @param {any} key\n * @param {T} value\n * @returns {T}\n */\nexport const set = (map, key, value) => {\n  map.set(key, value);\n  return value;\n};\n\n/**\n * Return a descriptor, if any, for the referenced *Element*\n * @param {Element} ref\n * @param {string} prop\n * @returns \n */\nexport const gPD = (ref, prop) => {\n  let desc;\n  do { desc = getOwnPropertyDescriptor(ref, prop); }\n  while(!desc && (ref = getPrototypeOf(ref)));\n  return desc;\n};\n\n/* c8 ignore start */\n/**\n * @param {DocumentFragment} content\n * @param {number[]} path\n * @returns {Element}\n */\nexport const find = (content, path) => path.reduceRight(childNodesIndex, content);\nconst childNodesIndex = (node, i) => node.childNodes[i];\n/* c8 ignore stop */\n","export const ELEMENT_NODE = 1;\nexport const ATTRIBUTE_NODE = 2;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n","const {setPrototypeOf} = Object;\n\n/**\n * @param {Function} Class any base class to extend without passing through it via super() call.\n * @returns {Function} an extensible class for the passed one.\n * @example\n *  // creating this very same module utility\n *  import custom from 'custom-function/factory';\n *  const CustomFunction = custom(Function);\n *  class MyFunction extends CustomFunction {}\n *  const mf = new MyFunction(() => {});\n */\nexport default Class => {\n  function Custom(target) {\n    return setPrototypeOf(target, new.target.prototype);\n  }\n  Custom.prototype = Class.prototype;\n  return Custom;\n};\n","import { newRange } from './utils.js';\n\nlet range;\n/**\n * @param {Node | Element} firstChild\n * @param {Node | Element} lastChild\n * @param {boolean} preserve\n * @returns\n */\nexport default (firstChild, lastChild, preserve) => {\n  if (!range) range = newRange();\n  /* c8 ignore start */\n  if (preserve)\n    range.setStartAfter(firstChild);\n  else\n    range.setStartBefore(firstChild);\n  /* c8 ignore stop */\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n","import { DOCUMENT_FRAGMENT_NODE } from 'domconstants/constants';\nimport custom from 'custom-function/factory';\nimport drop from './range.js';\nimport { empty } from './utils.js';\n\n/**\n * @param {PersistentFragment} fragment\n * @returns {Node | Element}\n */\nconst remove = ({firstChild, lastChild}, preserve) => drop(firstChild, lastChild, preserve);\n\nlet checkType = false;\n\n/**\n * @param {Node} node\n * @param {1 | 0 | -0 | -1} operation\n * @returns {Node}\n */\nexport const diffFragment = (node, operation) => (\n  checkType && node.nodeType === DOCUMENT_FRAGMENT_NODE ?\n    ((1 / operation) < 0 ?\n      (operation ? remove(node, true) : node.lastChild) :\n      (operation ? node.valueOf() : node.firstChild)) :\n    node\n);\n\nconst comment = value => document.createComment(value);\n\n/** @extends {DocumentFragment} */\nexport class PersistentFragment extends custom(DocumentFragment) {\n  #firstChild = comment('<>');\n  #lastChild = comment('</>');\n  #nodes = empty;\n  constructor(fragment) {\n    super(fragment);\n    this.replaceChildren(...[\n      this.#firstChild,\n      ...fragment.childNodes,\n      this.#lastChild,\n    ]);\n    checkType = true;\n  }\n  get firstChild() { return this.#firstChild; }\n  get lastChild() { return this.#lastChild; }\n  get parentNode() { return this.#firstChild.parentNode; }\n  remove() {\n    remove(this, false);\n  }\n  replaceWith(node) {\n    remove(this, true).replaceWith(node);\n  }\n  valueOf() {\n    const { parentNode } = this;\n    if (parentNode === this) {\n      if (this.#nodes === empty)\n        this.#nodes = [...this.childNodes];\n    }\n    else {\n      /* c8 ignore start */\n      // there are cases where a fragment might be just appended\n      // out of the box without valueOf() invoke (first render).\n      // When these are moved around and lose their parent and,\n      // such parent is not the fragment itself, it's possible there\n      // where changes or mutations in there to take care about.\n      // This is a render-only specific issue but it's tested and\n      // it's worth fixing to me to have more consistent fragments.\n      if (parentNode) {\n        let { firstChild, lastChild } = this;\n        this.#nodes = [firstChild];\n        while (firstChild !== lastChild)\n          this.#nodes.push((firstChild = firstChild.nextSibling));\n      }\n      /* c8 ignore stop */\n      this.replaceChildren(...this.#nodes);\n    }\n    return this;\n  }\n}\n","import udomdiff from 'udomdiff';\nimport { empty, gPD, isArray, set } from './utils.js';\nimport { diffFragment } from './persistent-fragment.js';\nimport drop from './range.js';\n\nconst setAttribute = (element, name, value) =>\n  element.setAttribute(name, value);\n\n/**\n * @param {Element} element\n * @param {string} name\n * @returns {void}\n */\nexport const removeAttribute = (element, name) =>\n  element.removeAttribute(name);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const aria = (element, value) => {\n  for (const key in value) {\n    const $ = value[key];\n    const name = key === 'role' ? key : `aria-${key}`;\n    if ($ == null) removeAttribute(element, name);\n    else setAttribute(element, name, $);\n  }\n  return value;\n};\n\nlet listeners;\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const at = (element, value, name) => {\n  name = name.slice(1);\n  if (!listeners) listeners = new WeakMap;\n  const known = listeners.get(element) || set(listeners, element, {});\n  let current = known[name];\n  if (current && current[0]) element.removeEventListener(name, ...current);\n  current = isArray(value) ? value : [value, false];\n  known[name] = current;\n  if (current[0]) element.addEventListener(name, ...current);\n  return value;\n};\n\n/** @type {WeakMap<Node, Element | import(\"./persistent-fragment.js\").PersistentFragment>} */\nconst holes = new WeakMap;\n\n/**\n * @template T\n * @param {import(\"./literals.js\").Detail} detail\n * @param {T} value\n * @returns {T}\n */\nexport const hole = (detail, value) => {\n  const { t: node, n: hole } = detail;\n  let nullish = false;\n  switch (typeof value) {\n    case 'object':\n      if (value !== null) {\n        (hole || node).replaceWith((detail.n = value.valueOf()));\n        break;\n      }\n    case 'undefined':\n      nullish = true;\n    default:\n      node.data = nullish ? '' : value;\n      if (hole) {\n        detail.n = null;\n        hole.replaceWith(node);\n      }\n      break;\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const className = (element, value) => maybeDirect(\n  element, value, value == null ? 'class' : 'className'\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const data = (element, value) => {\n  const { dataset } = element;\n  for (const key in value) {\n    if (value[key] == null) delete dataset[key];\n    else dataset[key] = value[key];\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element | CSSStyleDeclaration} ref\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const direct = (ref, value, name) => (ref[name] = value);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const dot = (element, value, name) => direct(element, value, name.slice(1));\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const maybeDirect = (element, value, name) => (\n  value == null ?\n    (removeAttribute(element, name), value) :\n    direct(element, value, name)\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const ref = (element, value) => (\n  (typeof value === 'function' ?\n    value(element) : (value.current = element)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nconst regular = (element, value, name) => (\n  (value == null ?\n    removeAttribute(element, name) :\n    setAttribute(element, name, value)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const style = (element, value) => (\n  value == null ?\n    maybeDirect(element, value, 'style') :\n    direct(element.style, value, 'cssText')\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const toggle = (element, value, name) => (\n  element.toggleAttribute(name.slice(1), value),\n  value\n);\n\n/**\n * @param {Node} node\n * @param {Node[]} value\n * @param {string} _\n * @param {Node[]} prev\n * @returns {Node[]}\n */\nexport const array = (node, value, prev) => {\n  // normal diff\n  const { length } = value;\n  node.data = `[${length}]`;\n  if (length)\n    return udomdiff(node.parentNode, prev, value, diffFragment, node);\n  /* c8 ignore start */\n  switch (prev.length) {\n    case 1:\n      prev[0].remove();\n    case 0:\n      break;\n    default:\n      drop(\n        diffFragment(prev[0], 0),\n        diffFragment(prev.at(-1), -0),\n        false\n      );\n      break;\n  }\n  /* c8 ignore stop */\n  return empty;\n};\n\nexport const attr = new Map([\n  ['aria', aria],\n  ['class', className],\n  ['data', data],\n  ['ref', ref],\n  ['style', style],\n]);\n\n/**\n * @param {HTMLElement | SVGElement} element\n * @param {string} name\n * @param {boolean} svg\n * @returns\n */\nexport const attribute = (element, name, svg) => {\n  switch (name[0]) {\n    case '.': return dot;\n    case '?': return toggle;\n    case '@': return at;\n    default: return (\n      svg || ('ownerSVGElement' in element) ?\n        (name === 'ref' ? ref : regular) :\n        (attr.get(name) || (\n          name in element ?\n            (name.startsWith('on') ?\n              direct :\n              (gPD(element, name)?.set ? maybeDirect : regular)\n            ) :\n            regular\n          )\n        )\n    );\n  }\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const text = (element, value) => (\n  (element.textContent = value == null ? '' : value),\n  value\n);\n","import { empty } from './utils.js';\n\n/** @typedef {import(\"./persistent-fragment.js\").PersistentFragment} PersistentFragment */\n/** @typedef {import(\"./rabbit.js\").Hole} Hole */\n\n/** @typedef {unknown} Value */\n/** @typedef {Node | Element | PersistentFragment} Target */\n/** @typedef {null | undefined | string | number | boolean | Node | Element | PersistentFragment} DOMValue */\n/** @typedef {Hole | Node} ArrayValue */\n\nexport const abc = (a, b, c) => ({ a, b, c });\n\nexport const bc = (b, c) => ({ b, c });\n\n/**\n * @typedef {Object} Detail\n * @property {any} v the current value of the interpolation / hole\n * @property {function} u the callback to update the value\n * @property {Node} t the target comment node or element\n * @property {string | null | Node} n the attribute name, if any, or `null`\n * @property {Cache | ArrayValue[] | null} c the cache value for this detail\n */\n\n/**\n * @returns {Detail}\n */\nexport const detail = (u, t, n, c) => ({ v: empty, u, t, n, c });\n\n/**\n * @typedef {Object} Entry\n * @property {number[]} a the path to retrieve the node\n * @property {function} b the update function\n * @property {string | null} c the attribute name, if any, or `null`\n */\n\n/**\n * @typedef {Object} Cache\n * @property {null | TemplateStringsArray} a the cached template\n * @property {null | Node | PersistentFragment} b the node returned when parsing the template\n * @property {Detail[]} c the list of updates to perform\n */\n\n/**\n * @returns {Cache}\n */\nexport const cache = () => abc(null, null, empty);\n","import { PersistentFragment } from './persistent-fragment.js';\nimport { bc, detail } from './literals.js';\nimport { array, hole } from './handler.js';\nimport { empty, find } from './utils.js';\nimport { cache } from './literals.js';\n\n/** @param {(template: TemplateStringsArray, values: any[]) => import(\"./parser.js\").Resolved} parse */\nexport default parse => (\n  /**\n   * @param {TemplateStringsArray} template\n   * @param {any[]} values\n   * @returns {import(\"./literals.js\").Cache}\n   */\n  (template, values) => {\n    const { a: fragment, b: entries, c: direct } = parse(template, values);\n    const root = document.importNode(fragment, true);\n    /** @type {import(\"./literals.js\").Detail[]} */\n    let details = empty;\n    if (entries !== empty) {\n      details = [];\n      for (let current, prev, i = 0; i < entries.length; i++) {\n        const { a: path, b: update, c: name } = entries[i];\n        const node = path === prev ? current : (current = find(root, (prev = path)));\n        details[i] = detail(\n          update,\n          node,\n          name,\n          update === array ? [] : (update === hole ? cache() : null)\n        );\n      }\n    }\n    return bc(\n      direct ? root.firstChild : new PersistentFragment(root),\n      details,\n    );\n  }\n);\n","export const TEXT_ELEMENTS = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\nexport const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n","import { VOID_ELEMENTS } from 'domconstants/re';\n\nconst elements = /<([a-zA-Z0-9]+[a-zA-Z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} xml enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, xml) => {\n  let i = 0;\n  return template\n    .join('\\x01')\n    .trim()\n    .replace(\n      elements,\n      (_, name, attrs, selfClosing) => `<${\n          name\n        }${\n          attrs.replace(attributes, '\\x02=$2$1').trimEnd()\n        }${\n          selfClosing ? (\n            (xml || VOID_ELEMENTS.test(name)) ? ' /' : `></${name}`\n          ) : ''\n        }>`\n    )\n    .replace(\n      holes,\n      hole => hole === '\\x01' ? `<!--${prefix + i++}-->` : (prefix + i++)\n    )\n  ;\n};\n","import { SVG_NAMESPACE, newRange } from './utils.js';\n\nlet template = document.createElement('template'), svg, range;\n\n/**\n * @param {string} text\n * @param {boolean} xml\n * @returns {DocumentFragment}\n */\nexport default (text, xml) => {\n  if (xml) {\n    if (!svg) {\n      svg = document.createElementNS(SVG_NAMESPACE, 'svg');\n      range = newRange();\n      range.selectNodeContents(svg);\n    }\n    return range.createContextualFragment(text);\n  }\n  template.innerHTML = text;\n  const { content } = template;\n  template = template.cloneNode(false);\n  return content;\n};\n","import { COMMENT_NODE, ELEMENT_NODE } from 'domconstants/constants';\nimport { TEXT_ELEMENTS } from 'domconstants/re';\nimport parser from '@webreflection/uparser';\n\nimport { empty, isArray, set } from './utils.js';\nimport { abc } from './literals.js';\n\nimport { array, attribute, hole, text, removeAttribute } from './handler.js';\nimport createContent from './create-content.js';\n\n/** @typedef {import(\"./literals.js\").Entry} Entry */\n\n/**\n * @typedef {Object} Resolved\n * @param {DocumentFragment} f content retrieved from the template\n * @param {Entry[]} e entries per each hole in the template\n * @param {boolean} d direct node to handle\n */\n\n/**\n * @param {Element} node\n * @returns {number[]}\n */\nconst createPath = node => {\n  const path = [];\n  let parentNode;\n  while ((parentNode = node.parentNode)) {\n    path.push(path.indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n  }\n  return path;\n};\n\nconst textNode = () => document.createTextNode('');\n\n/**\n * @param {TemplateStringsArray} template\n * @param {boolean} xml\n * @returns {Resolved}\n */\nconst resolve = (template, values, xml) => {\n  const content = createContent(parser(template, prefix, xml), xml);\n  const { length } = template;\n  let entries = empty;\n  if (length > 1) {\n    const replace = [];\n    const tw = document.createTreeWalker(content, 1 | 128);\n    let i = 0, search = `${prefix}${i++}`;\n    entries = [];\n    while (i < length) {\n      const node = tw.nextNode();\n      // these are holes or arrays\n      if (node.nodeType === COMMENT_NODE) {\n        if (node.data === search) {\n          // ⚠️ once array, always array!\n          const update = isArray(values[i - 1]) ? array : hole;\n          if (update === hole) replace.push(node);\n          entries.push(abc(createPath(node), update, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n      else {\n        let path;\n        // these are attributes\n        while (node.hasAttribute(search)) {\n          if (!path) path = createPath(node);\n          const name = node.getAttribute(search);\n          entries.push(abc(path, attribute(node, name, xml), name));\n          removeAttribute(node, search);\n          search = `${prefix}${i++}`;\n        }\n        // these are special text-only nodes\n        if (\n          !xml &&\n          TEXT_ELEMENTS.test(node.localName) &&\n          node.textContent.trim() === `<!--${search}-->`\n        ) {\n          entries.push(abc(path || createPath(node), text, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n    }\n    // can't replace holes on the fly or the tree walker fails\n    for (i = 0; i < replace.length; i++)\n      replace[i].replaceWith(textNode());\n  }\n\n  // need to decide if there should be a persistent fragment\n  const { childNodes } = content;\n  let { length: len } = childNodes;\n\n  // html`` or svg`` to signal an empty content\n  // these nodes can be passed directly as never mutated\n  if (len < 1) {\n    len = 1;\n    content.appendChild(textNode());\n  }\n  // html`${'b'}` or svg`${[]}` cases\n  else if (\n    len === 1 &&\n    // ignore html`static` or svg`static` because\n    // these nodes can be passed directly as never mutated\n    length !== 1 &&\n    childNodes[0].nodeType !== ELEMENT_NODE\n  ) {\n    // use a persistent fragment for these cases too\n    len = 0;\n  }\n\n  return set(cache, template, abc(content, entries, len === 1));\n};\n\n/** @type {WeakMap<TemplateStringsArray, Resolved>} */\nconst cache = new WeakMap;\nconst prefix = 'isµ';\n\n/**\n * @param {boolean} xml\n * @returns {(template: TemplateStringsArray, values: any[]) => Resolved}\n */\nexport default xml => (template, values) => cache.get(template) || resolve(template, values, xml);\n","import { array, hole } from './handler.js';\nimport { cache } from './literals.js';\nimport create from './creator.js';\nimport parser from './parser.js';\n\nconst createHTML = create(parser(false));\nconst createSVG = create(parser(true));\n\n/**\n * @param {import(\"./literals.js\").Cache} info\n * @param {Hole} hole\n * @returns {Node}\n */\nconst unroll = (info, { s, t, v }) => {\n  if (info.a !== t) {\n    const { b, c } = (s ? createSVG : createHTML)(t, v);\n    info.a = t;\n    info.b = b;\n    info.c = c;\n  }\n  for (let { c } = info, i = 0; i < c.length; i++) {\n    const value = v[i];\n    const detail = c[i];\n    switch (detail.u) {\n      case array:\n        detail.v = array(\n          detail.t,\n          unrollValues(detail.c, value),\n          detail.v\n        );\n        break;\n      case hole:\n        const current = value instanceof Hole ?\n          unroll(detail.c || (detail.c = cache()), value) :\n          (detail.c = null, value)\n        ;\n        if (current !== detail.v)\n          detail.v = hole(detail, current);\n        break;\n      default:\n        if (value !== detail.v)\n          detail.v = detail.u(detail.t, value, detail.n, detail.v);\n        break;\n    }\n  }\n  return info.b;\n};\n\n/**\n * @param {Cache} cache\n * @param {any[]} values\n * @returns {number}\n */\nconst unrollValues = (stack, values) => {\n  let i = 0, { length } = values;\n  if (length < stack.length) stack.splice(length);\n  for (; i < length; i++) {\n    const value = values[i];\n    if (value instanceof Hole)\n      values[i] = unroll(stack[i] || (stack[i] = cache()), value);\n    else stack[i] = null;\n  }\n  return values;\n};\n\n/**\n * Holds all details needed to render the content on a render.\n * @constructor\n * @param {boolean} svg The content type.\n * @param {TemplateStringsArray} template The template literals used to the define the content.\n * @param {any[]} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(svg, template, values) {\n    this.s = svg;\n    this.t = template;\n    this.v = values;\n  }\n  toDOM(info = cache()) {\n    return unroll(info, this);\n  }\n};\n","/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\n\nimport render from './render/hole.js';\n\n/** @typedef {import(\"./literals.js\").Value} Value */\n\nconst tag = svg => (template, ...values) => new Hole(svg, template, values);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render HTML content. */\nexport const html = tag(false);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render SVG content. */\nexport const svg = tag(true);\n\nexport { Hole, render, attr };\n","import { Hole } from '../rabbit.js';\nimport { cache } from '../literals.js';\nimport { set } from '../utils.js';\n\n/** @type {WeakMap<Element | DocumentFragment, import(\"../literals.js\").Cache>} */\nconst known = new WeakMap;\n\n/**\n  * Render with smart updates within a generic container.\n  * @template T\n  * @param {T} where the DOM node where to render content\n  * @param {(() => Hole) | Hole} what the hole to render\n  * @param {boolean} check does a `typeof` check (internal usage).\n  * @returns\n  */\nexport default (where, what, check) => {\n  const info = known.get(where) || set(known, where, cache());\n  const { b } = info;\n  const hole = (check && typeof what === 'function') ? what() : what;\n  const node = hole instanceof Hole ? hole.toDOM(info) : hole;\n  if (b !== node)\n    where.replaceChildren((info.b = node).valueOf());\n  return where;\n};\n","// (c) Andrea Giammarchi - ISC\n\nconst registry = new FinalizationRegistry(\n  ([onGarbageCollected, held, debug]) => {\n    // \"%cThis is a green text\", \"color:green\"\n    if (debug) console.debug(`%c${String(held)}`, 'font-weight:bold', 'collected');\n    onGarbageCollected(held);\n  }\n);\n\nconst nullHandler = Object.create(null);\n\n/**\n * @template {unknown} H\n * @typedef {Object} GCHookOptions\n * @prop {boolean} [debug=false] if `true`, logs values once these can get collected.\n * @prop {ProxyHandler<object>} [handler] optional proxy handler to use instead of the default one.\n * @prop {H} [return=H] if specified, overrides the returned proxy with its value.\n * @prop {unknown} [token=H] it's the held value by default, but it can be any other token except the returned value itself.\n */\n\n/**\n * @template {unknown} H\n * @param {H} hold the reference to hold behind the scene and passed along the callback once it triggers.\n * @param {(held:H) => void} onGarbageCollected the callback that will receive the held value once its wrapper or indirect reference is no longer needed.\n * @param {GCHookOptions<H>} [options] an optional configuration object to change some default behavior.\n */\nexport const create = (\n  hold,\n  onGarbageCollected,\n  { debug, handler, return: r, token = hold } = nullHandler\n) => {\n  // if no reference to return is defined,\n  // create a proxy for the held one and register that instead.\n  /** @type {H} */\n  const target = r || new Proxy(hold, handler || nullHandler);\n  const args = [target, [onGarbageCollected, hold, !!debug]];\n  if (token !== false) args.push(token);\n  // register the target reference in a way that\n  // the `onGarbageCollected(held)` callback will eventually notify.\n  registry.register(...args);\n  return target;\n};\n\n/**\n * If previously registered as either `token` or `hold` value, allow explicit removal of the entry in the registry.\n * @param {unknown} token the token used during registration. If no `token` was passed, this can be the same `hold` reference.\n * @returns {boolean} `true` if successfully unregistered.\n */\nexport const drop = token => registry.unregister(token);\n","import { create, drop } from 'gc-hook';\n\nimport render from './shared.js';\n\n/** @typedef {import(\"../rabbit.js\").Hole} Hole */\n\n/** @type {WeakMap<Element | DocumentFragment, Function>} */\nconst effects = new WeakMap;\n\n/**\n * @param {Function} dispose\n * @returns {void}\n */\nconst onGC = dispose => dispose();\n\nlet remove = true;\n\n/**\n * @param {Function} effect the reactive `effect` callback provided by a 3rd party library.\n * @returns \n */\nexport const attach = effect => {\n  /**\n   * Render with smart updates within a generic container.\n   * If the `what` is a function, it automatically create\n   * an effect for the render function.\n   * @template T\n   * @param {T} where the DOM node where to render content\n   * @param {(() => Hole) | Hole} what the hole to render\n   * @returns {T}\n   */\n  return (where, what) => {\n    remove = typeof what !== 'function';\n    detach(where);\n\n    if (remove) return render(where, what, false);\n    remove = true;\n\n    const wr = new WeakRef(where);\n    const dispose = effect(() => { render(wr.deref(), what(), false) });\n    effects.set(where, dispose);\n    return create(dispose, onGC, { return: where });\n  };\n};\n\n/**\n * Allow manual cleanup of subscribed signals.\n * @param {Element} where a reference container previously used to render signals.\n */\nexport const detach = where => {\n  const dispose = effects.get(where);\n  if (dispose) {\n    if (remove) effects.delete(where);\n    drop(dispose);\n    dispose();\n  }\n};\n","import { effect, signal, computed } from 'uhtml/signal';\nimport { reactive, html } from 'uhtml/reactive';\n\n// define Renderer\nconst render = reactive(effect); // 🆕 replaces uhtmlRender\n\n// HTML\nexport { html };\n\n// DEV env\nexport const isDev = location.hostname === 'localhost' || location.hostname === '127.0.0.1';\n//export const isDev = false;\n\n// logdev\nexport const logdev = (...m) => (isDev) && console.debug(`[KartonJS]`, ...m);\n\n// memoryStorage \nexport const memoryStorage = {\n  items: {},\n  setItem: (key, value) => memoryStorage.items[key] = value,\n  getItem: (key) => memoryStorage.items[key] || null,\n  removeItem: (key) => delete memoryStorage[key],\n  clear: () => memoryStorage.items = {}\n};\n\n// wait for requestAnimationFrame\nexport async function sleepUntilAnimationFrame() { \n  await new Promise(requestAnimationFrame);\n  return true;\n}\n\n// stateBus pub/sub - no export - only used within KartonElement\nconst stateBus = (() => {\n  const listeners = new Map();\n\n  return {\n    subscribe(key, callback) {\n      if (!listeners.has(key)) listeners.set(key, new Set());\n      listeners.get(key).add(callback);\n      return () => listeners.get(key).delete(callback);\n    },\n    publish(key, value) {\n      if (listeners.has(key)) {\n        for (const cb of listeners.get(key)) cb(value);\n        return true;\n      } else {\n        return;\n      }\n    }\n  };\n})();\n\n// KartonElement to be extended by you\nexport class KartonElement extends HTMLElement {\n  #state = {};\n  #effects = [];\n  #unsubscribers = [];\n  #renderPending = false;\n\n  Storage = memoryStorage;\n\n  $ = (s) => document.querySelector(s);  \n  $$ = (s) => document.querySelectorAll(s);\n\n  constructor() {\n    super();\n    this.attachLightDom();\n  }\n\n  attachLightDom() {\n    // optional: you can just use `this` since it's light DOM by default\n  }\n\n  extractTemplateSlots(host = this) {\n    const slotMap = {};\n    const templates = host.querySelectorAll('template[slot]');\n    for (const tmpl of templates) {\n      const name = tmpl.getAttribute('slot');\n      const fragment = tmpl.content.cloneNode(true);\n      if( [\"application/json\", \"json\"].includes(tmpl.getAttribute('type')?.toLowerCase() || \"\") ) {\n        const rawContent = fragment.textContent;\n        slotMap[name] = this.safeJsonParse(rawContent);\n      } else {\n        slotMap[name] = fragment;\n      }\n      tmpl.remove(); // Optional: remove templates so they don't render in DOM\n    }\n    \n    return slotMap;\n  }\n  \n  slot(name) {\n    return this.slots[name] || this.defaultContent[name] || \"?? undefined slot ??\";\n  }\n  \n  safeJsonParse(json) {\n      try {\n        return JSON.parse(json);\n      } catch (e) {\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> Failed to parse JSON script config within element`, e);\n        return null;\n      }\n  }\n\n  connectedCallback() {\n    // Define i\n    this.i = this.id || \"anonymous\";\n  \n    // Define Development tools integration\n    if (isDev) {\n      if (!window.__Karton__) {\n        window.__Karton__ = { instances: new Set() };\n      }\n      window.__Karton__.instances.add(this);\n    }\n    \n    // user-defined initialization\n    this.init();\n    \n    // render\n    if (typeof this.template === 'function') {\n      try {\n        render(this, this.template.bind(this));\n      } catch (e) {\n        throw console.error(\"Error during rendering!\\nPlease notice that KartonElement is using render() from 'uthml' and for example: class=\\\"button ${varname}\\\" is not allowed, only class=${varname}.\\nTo know for sure that your template renders, please read: https://webreflection.github.io/uhtml/\", e);\n      }\n    }\n  }\n\n  disconnectedCallback() {\n    for (const unsub of this.#unsubscribers) unsub();\n    this.#unsubscribers = [];\n\n    window.__Karton__?.instances.delete(this);\n\n    for (const { label, cleanup } of this.#effects) {\n      logdev(`<${this.tagName.toLowerCase()} id=${this.i}> Cleaning up effect: ${label}`);\n      if (typeof cleanup === 'function') cleanup();\n    }\n    this.#effects = [];\n  }\n\n  init() {\n    // To be overridden by subclasses\n  }\n\n  coerce(v) {\n    if (v === 'true') return true;\n    if (v === 'false') return false;\n    if (!isNaN(parseFloat(v)) && isFinite(v)) return Number(v);\n    return v;\n  }\n\n  State(key, initialValue, storage = this.Storage) {\n    if (!(key in this.#state)) {\n      let value;\n\n      if (this.hasAttribute(key)) {\n        value = this.coerce(this.getAttribute(key)) || this.hasAttribute(key) && this.getAttribute(key) !== 'false';\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> State '${key}' initialized by getAttribute:`, value);\n      } else if (storage.getItem(key) !== null) {\n        value = this.coerce(storage.getItem(key));\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> State '${key}' initialized by Storage:`, value);\n      } else {\n        value = initialValue;\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> State '${key}' initialized by initialValue:`, value);\n      }\n\n      const s = signal(value);\n      this.#state[key] = s;\n\n      const cleanup = effect(() => {\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> State '${key}' changed: `, s.value);\n        this.reflectAttribute(key, s.value) && logdev(`attribute reflected '${key}':`, s.value);\n        storage.setItem(key, s.value) && logdev(`stored in Storage '${key}':`, s.value);\n      });\n\n      this.#effects.push({ label: `state:${key}`, cleanup });\n    }\n\n    const s = this.#state[key];\n    return [() => s.value, v => s.value = v];\n  }\n\n  BusState(key, initialValue, storage = this.Storage) {\n    let s;\n    const alreadyExists = key in this.#state;\n    if (!alreadyExists) {\n      let value;\n      if (this.hasAttribute(key)) {\n        value = this.coerce(this.getAttribute(key)) || this.hasAttribute(key) && this.getAttribute(key) !== 'false';\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> BusState '${key}' initialized by getAttribute:`, value);\n      } else if (storage.getItem(key) !== null) {\n        value = this.coerce(storage.getItem(key));\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> BusState '${key}' initialized by Storage:`, value);\n      } else {\n        value = initialValue;\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> BusState '${key}' initialized by initialValue:`, value);\n      }\n      s = signal(value);\n      this.#state[key] = s;\n    } else {\n      s = this.#state[key];\n    }\n\n    const unsubscribe = stateBus.subscribe(key, newVal => {\n      logdev(`[${this.id}] SUB: ${key} =`, newVal);\n      if (s.value !== newVal) s.value = newVal;\n    });\n    this.#unsubscribers.push(unsubscribe);\n\n    const hasEffect = this.#effects.some(e => e.label === `bus:${key}`);\n    if (!hasEffect) {\n      const cleanup = effect(() => {\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> BusState '${key}' changed:`, s.value);\n        stateBus.publish(key, s.value) && logdev(`PUB '${key}':`, s.value);\n        this.reflectAttribute(key, s.value) && logdev(`attribute reflected '${key}':`, s.value);\n        storage.setItem(key, s.value) && logdev(`stored in Storage '${key}':`, s.value);\n      });\n      this.#effects.push({ label: `bus:${key}`, cleanup });\n    }\n\n    return [() => s.value, v => s.value = v];\n  }\n\n  StateSignal(initialValue) {\n    const s = signal(initialValue);\n    return [() => s.value, v => s.value = v];\n  }\n\n  reflectAttribute(key, val) {\n    let oAttr = this.constructor.observedAttributes || [];\n    if (oAttr.includes(key) && val !== null) {\n      return this.setAttribute(key, val);\n    } else {\n      return;\n    }\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (oldValue === newValue) return;\n    logdev(`<${this.tagName.toLowerCase()} id=${this.i}> '${name}' attributeChanged:`, oldValue, '→', newValue);\n\n    const coerced = this.coerce(newValue) || this.hasAttribute(name) && this.getAttribute(name) !== 'false';\n    if (name in this.#state && this.#state[name].value !== coerced) {\n      this.#state[name].value = coerced;\n      stateBus.publish(name, coerced);\n    }\n  }\n\n  Effect(fn, depsOrLabel) {\n    let label = 'anonymous';\n    let deps = null;\n\n    if (Array.isArray(depsOrLabel)) {\n      deps = depsOrLabel;\n    } else if (typeof depsOrLabel === 'string') {\n      label = depsOrLabel;\n    }\n\n    const run = () => {\n      logdev(`<${this.tagName.toLowerCase()} id=${this.i}> Effect Triggered: ${label}`);\n      const result = fn();\n      return typeof result === 'function' ? result : null;\n    };\n\n    const cleanup = deps\n      ? effect(() => {\n          deps.map(d => d()); // for tracking\n          return run();\n        })\n      : effect(run);\n\n    this.#effects.push({ label, cleanup });\n  }\n\n  runEffects() {\n    this.#effects.forEach(effect => {\n      const shouldRun =\n        effect.last.length !== effect.deps.length ||\n        effect.deps.some((dep, i) => dep() !== effect.last[i]);\n\n      if (shouldRun) {\n        if (typeof effect.cleanup === 'function') {\n          effect.cleanup();\n        }\n\n        const result = effect.fn();\n        effect.cleanup = typeof result === 'function' ? result : null;\n        effect.last = effect.deps.map(dep => dep());\n      }\n    });\n  }\n\n  Computed(computeFn, key) {\n    if (typeof computeFn !== 'function') {\n      throw new Error(`Computed expects a function, but got: ${typeof computeFn}`);\n    }\n\n    if (!(key in this.#state)) {\n      const c = computed(computeFn);\n      this.#state[key] = c;\n\n      const cleanup = effect(() => {\n        const val = c.value;\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> '${key}' computed updated:`, val);\n      });\n\n      this.#effects.push({ label: `computed:${key}`, cleanup });\n    }\n\n    const c = this.#state[key];\n    return () => c.value;\n  }\n  \n  BoolAttrEffect(attr, getter) {\n    this.Effect(() => {\n      const val = getter();\n      if (val === false || val === null || val === undefined) {\n        this.removeAttribute(attr);\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> attribute '${attr}' removed`);\n      } else {\n        this.setAttribute(attr, '');\n        logdev(`<${this.tagName.toLowerCase()} id=${this.i}> attribute '${attr}' added`);\n      }\n    }, [getter]);\n  }\n\n  SyncAttrEffect(attrName, getter) {\n    this.Effect(() => {\n      this.setAttribute(attrName, getter());\n    }, [() => getter()]);\n  }\n\n}\n"],"names":["create","effect","ref","range","remove","drop","known","current","detail","hole","svg","cache","template","direct","prefix","text","parser","render","reactive","listeners","s","c","attr"],"mappings":";;;;;;;;;;AAAA;AAAA;AAoBA,MAAM,UAAU,UAAQ;AACtB,QAAM,UAAU,CAAC,GAAG,IAAI;AACxB,OAAK,MAAO;AACZ,SAAO;AACT;AAEA,MAAM,eAAe,IAAI;AAAA,EACvB,YAAY,GAAG;AAAE,UAAO,EAAC,IAAI;AAAA,EAAC;AAAA,EAC9B,UAAU;AA5BZ;AA6BI,eAAW,SAAS,QAAQ,IAAI,GAAG;AACjC,YAAM,OAAO,IAAI;AACjB,kBAAM,YAAN;AAAA,IACN;AAAA,EACA;AACA;AAEA,IAAI,UAAU;AACd,MAAMA,WAAS,CAAC,UAAU;AACxB,QAAM,KAAK,IAAI,OAAO,MAAM;AAC1B,UAAM,OAAO;AACb,cAAU;AACV,QAAI;AAAE,YAAO;AAAA,IAAA,UACL;AAAE,gBAAU;AAAA,IAAI;AAAA,EAC5B,CAAG;AACD,SAAO;AACT;AAQO,MAAM,SAAS,CAAC,OAAO;AAC5B,MAAI,UAAU,KAAKA,SAAO,MAAM;AAtDlC;AAsDoC,+CAAU,SAAV;AAAoB,eAAW,GAAE;AAAA,GAAI;AACvE,MAAI,QAAS,SAAQ,IAAI,EAAE;AAC3B,SAAO,GAAG,EAAC,GAAI,MAAO;AAxDxB;AAwDwB,sDAAU,SAAV,mCAAoB,GAAG;;AAC/C;AAmBO,MAAM,eAAe,IAAI;AAAA;AAAA,EAG9B,YAAY,GAAG;AAAE,UAAO,EAAC,IAAI;AAAA,EAAC;AAAA;AAAA,EAG9B,IAAI,QAAQ;AACV,QAAI,QAAS,SAAQ,IAAI,KAAK,IAAI,OAAO,CAAC;AAC1C,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGE,IAAI,MAAM,GAAG;AACX,QAAI,KAAK,MAAM,GAAG;AAChB,WAAK,IAAI;AAET,iBAAWC,WAAU,QAAQ,IAAI,GAAG;AACxB,QAAAA,QAAO,EAAG;AAAA,MAE5B;AAAA,IACA;AAAA,EACA;AAAA;AAAA,EAGE,OAAO;AAAE,WAAO,KAAK;AAAA,EAAC;AAAA;AAAA,EAGtB,SAAS;AAAE,WAAO,KAAK;AAAA,EAAK;AAAA,EAC5B,UAAU;AAAE,WAAO,KAAK;AAAA,EAAK;AAAA,EAC7B,WAAW;AAAE,WAAO,OAAO,KAAK,KAAK;AAAA,EAAC;AACxC;AAOO,MAAM,SAAS,WAAS,IAAI,OAAO,KAAK;AAQxC,MAAM,iBAAiB,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKnC,YAAY,IAAI,OAAO;AACrB,UAAM,KAAK,EAAE,IAAI;AACjB,SAAK,IAAI;AAAA,EACb;AAAA;AAAA,EAGE,IAAI,QAAQ;AACV,QAAI,CAAC,KAAK;AACR,OAAC,KAAK,IAAID,SAAO,MAAM;AAAE,cAAM,QAAQ,KAAK,EAAE,KAAK,CAAC;AAAA,MAAG,CAAA,GAAG,EAAG;AAC/D,WAAO,MAAM;AAAA,EACjB;AAAA;AAAA,EAGE,IAAI,MAAM,GAAG;AAAE,UAAM,IAAI,MAAM,uBAAuB;AAAA,EAAC;AACzD;AAQO,MAAM,WAAW,CAAC,IAAI,UAAU,IAAI,SAAS,IAAI,KAAK;ACzH7D,MAAe,WAAA,CAAC,YAAY,GAAG,GAAG,KAAK,WAAW;AAChD,QAAM,UAAU,EAAE;AAClB,MAAI,OAAO,EAAE;AACb,MAAI,OAAO;AACX,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,MAAM;AACV,SAAO,SAAS,QAAQ,SAAS,MAAM;AAErC,QAAI,SAAS,QAAQ;AAKnB,YAAM,OAAO,OAAO,UACjB,SACE,IAAI,EAAE,SAAS,CAAC,GAAG,EAAE,EAAE,cACxB,IAAI,EAAE,IAAI,GAAG,CAAC,IAChB;AACF,aAAO,SAAS;AACd,mBAAW,aAAa,IAAI,EAAE,QAAQ,GAAG,CAAC,GAAG,IAAI;AAAA,IACzD,WAEa,SAAS,QAAQ;AACxB,aAAO,SAAS,MAAM;AAEpB,YAAI,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE,MAAM,CAAC;AAC5B,qBAAW,YAAY,IAAI,EAAE,MAAM,GAAG,EAAE,CAAC;AAC3C;AAAA,MACR;AAAA,IACA,WAEa,EAAE,MAAM,MAAM,EAAE,MAAM,GAAG;AAChC;AACA;AAAA,IACN,WAEa,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,GAAG;AACpC;AACA;AAAA,IACN,WAKM,EAAE,MAAM,MAAM,EAAE,OAAO,CAAC,KACxB,EAAE,MAAM,MAAM,EAAE,OAAO,CAAC,GACxB;AAOA,YAAM,OAAO,IAAI,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;AAChC,iBAAW;AAAA,QACT,IAAI,EAAE,QAAQ,GAAG,CAAC;AAAA,QAClB,IAAI,EAAE,QAAQ,GAAG,EAAE,EAAE;AAAA,MACtB;AACD,iBAAW,aAAa,IAAI,EAAE,EAAE,IAAI,GAAG,CAAC,GAAG,IAAI;AAO/C,QAAE,IAAI,IAAI,EAAE,IAAI;AAAA,IACtB,OAES;AAMH,UAAI,CAAC,KAAK;AACR,cAAM,oBAAI;AACV,YAAI,IAAI;AACR,eAAO,IAAI;AACT,cAAI,IAAI,EAAE,CAAC,GAAG,GAAG;AAAA,MAC3B;AAEM,UAAI,IAAI,IAAI,EAAE,MAAM,CAAC,GAAG;AAEtB,cAAM,QAAQ,IAAI,IAAI,EAAE,MAAM,CAAC;AAE/B,YAAI,SAAS,SAAS,QAAQ,MAAM;AAClC,cAAI,IAAI;AAER,cAAI,WAAW;AACf,iBAAO,EAAE,IAAI,QAAQ,IAAI,QAAQ,IAAI,IAAI,EAAE,CAAC,CAAC,MAAO,QAAQ;AAC1D;AAWF,cAAI,WAAY,QAAQ,QAAS;AAC/B,kBAAM,OAAO,IAAI,EAAE,MAAM,GAAG,CAAC;AAC7B,mBAAO,SAAS;AACd,yBAAW,aAAa,IAAI,EAAE,QAAQ,GAAG,CAAC,GAAG,IAAI;AAAA,UAC/D,OAIe;AACH,uBAAW;AAAA,cACT,IAAI,EAAE,QAAQ,GAAG,CAAC;AAAA,cAClB,IAAI,EAAE,QAAQ,GAAG,EAAE;AAAA,YACpB;AAAA,UACb;AAAA,QACA;AAGU;AAAA,MACV;AAKQ,mBAAW,YAAY,IAAI,EAAE,QAAQ,GAAG,EAAE,CAAC;AAAA,IACnD;AAAA,EACA;AACE,SAAO;AACT;AC5JA,MAAM,EAAE,QAAS,IAAG;AACpB,MAAM,EAAE,gBAAgB,yBAAwB,IAAK;AAI9C,MAAM,gBAAgB;AAEtB,MAAM,QAAQ,CAAE;AAEhB,MAAM,WAAW,MAAM,SAAS,YAAa;AAU7C,MAAM,MAAM,CAAC,KAAK,KAAK,UAAU;AACtC,MAAI,IAAI,KAAK,KAAK;AAClB,SAAO;AACT;AAQO,MAAM,MAAM,CAACE,MAAK,SAAS;AAChC,MAAI;AACJ,KAAG;AAAE,WAAO,yBAAyBA,MAAK,IAAI;AAAA,EAAE,SAC1C,CAAC,SAASA,OAAM,eAAeA,IAAG;AACxC,SAAO;AACT;AAQO,MAAM,OAAO,CAAC,SAAS,SAAS,KAAK,YAAY,iBAAiB,OAAO;AAChF,MAAM,kBAAkB,CAAC,MAAM,MAAM,KAAK,WAAW,CAAC;AC5C/C,MAAM,eAAe;AAGrB,MAAM,eAAe;AAGrB,MAAM,yBAAyB;ACNtC,MAAM,EAAC,eAAc,IAAI;AAYzB,MAAA,SAAe,WAAS;AACtB,WAAS,OAAO,QAAQ;AACtB,WAAO,eAAe,QAAQ,WAAW,SAAS;AAAA,EACtD;AACE,SAAO,YAAY,MAAM;AACzB,SAAO;AACT;AChBA,IAAIC;AAOJ,MAAA,SAAe,CAAC,YAAY,WAAW,aAAa;AAClD,MAAI,CAACA,QAAOA,WAAQ,SAAU;AAE9B,MAAI;AACFA,YAAM,cAAc,UAAU;AAAA;AAE9BA,YAAM,eAAe,UAAU;AAEjCA,UAAM,YAAY,SAAS;AAC3BA,UAAM,eAAgB;AACtB,SAAO;AACT;ACXA,MAAMC,WAAS,CAAC,EAAC,YAAY,UAAS,GAAG,aAAaC,OAAK,YAAY,WAAW,QAAQ;AAE1F,IAAI,YAAY;AAOT,MAAM,eAAe,CAAC,MAAM,cACjC,aAAa,KAAK,aAAa,yBAC3B,IAAI,YAAa,IAChB,YAAYD,SAAO,MAAM,IAAI,IAAI,KAAK,YACtC,YAAY,KAAK,YAAY,KAAK,aACrC;AAGJ,MAAM,UAAU,WAAS,SAAS,cAAc,KAAK;AAG9C,MAAM,2BAA2B,OAAO,gBAAgB,EAAE;AAAA,EAI/D,YAAY,UAAU;AACpB,UAAM,QAAQ;AAJhB,oCAAc,QAAQ,IAAI;AAC1B,mCAAa,QAAQ,KAAK;AAC1B,+BAAS;AAGP,SAAK,gBAAgB,GAAG;AAAA,MACtB,mBAAK;AAAA,MACL,GAAG,SAAS;AAAA,MACZ,mBAAK;AAAA,IACX,CAAK;AACD,gBAAY;AAAA,EAChB;AAAA,EACE,IAAI,aAAa;AAAE,WAAO,mBAAK;AAAA,EAAY;AAAA,EAC3C,IAAI,YAAY;AAAE,WAAO,mBAAK;AAAA,EAAW;AAAA,EACzC,IAAI,aAAa;AAAE,WAAO,mBAAK,aAAY;AAAA,EAAW;AAAA,EACtD,SAAS;AACPA,aAAO,MAAM,KAAK;AAAA,EACtB;AAAA,EACE,YAAY,MAAM;AAChBA,aAAO,MAAM,IAAI,EAAE,YAAY,IAAI;AAAA,EACvC;AAAA,EACE,UAAU;AACR,UAAM,EAAE,WAAU,IAAK;AACvB,QAAI,eAAe,MAAM;AACvB,UAAI,mBAAK,YAAW;AAClB,2BAAK,QAAS,CAAC,GAAG,KAAK,UAAU;AAAA,IACzC,OACS;AASH,UAAI,YAAY;AACd,YAAI,EAAE,YAAY,UAAS,IAAK;AAChC,2BAAK,QAAS,CAAC,UAAU;AACzB,eAAO,eAAe;AACpB,6BAAK,QAAO,KAAM,aAAa,WAAW,WAAa;AAAA,MACjE;AAEM,WAAK,gBAAgB,GAAG,mBAAK,OAAM;AAAA,IACzC;AACI,WAAO;AAAA,EACX;AACA;AA/CE;AACA;AACA;AC3BF,MAAM,eAAe,CAAC,SAAS,MAAM,UACnC,QAAQ,aAAa,MAAM,KAAK;AAO3B,MAAM,kBAAkB,CAAC,SAAS,SACvC,QAAQ,gBAAgB,IAAI;AAQvB,MAAM,OAAO,CAAC,SAAS,UAAU;AACtC,aAAW,OAAO,OAAO;AACvB,UAAM,IAAI,MAAM,GAAG;AACnB,UAAM,OAAO,QAAQ,SAAS,MAAM,QAAQ,GAAG;AAC/C,QAAI,KAAK,KAAM,iBAAgB,SAAS,IAAI;AAAA,QACvC,cAAa,SAAS,MAAM,CAAC;AAAA,EACtC;AACE,SAAO;AACT;AAEA,IAAI;AASG,MAAM,KAAK,CAAC,SAAS,OAAO,SAAS;AAC1C,SAAO,KAAK,MAAM,CAAC;AACnB,MAAI,CAAC,UAAW,aAAY,oBAAI;AAChC,QAAME,SAAQ,UAAU,IAAI,OAAO,KAAK,IAAI,WAAW,SAAS,EAAE;AAClE,MAAIC,WAAUD,OAAM,IAAI;AACxB,MAAIC,YAAWA,SAAQ,CAAC,EAAG,SAAQ,oBAAoB,MAAM,GAAGA,QAAO;AACvE,EAAAA,WAAU,QAAQ,KAAK,IAAI,QAAQ,CAAC,OAAO,KAAK;AAChD,EAAAD,OAAM,IAAI,IAAIC;AACd,MAAIA,SAAQ,CAAC,EAAG,SAAQ,iBAAiB,MAAM,GAAGA,QAAO;AACzD,SAAO;AACT;AAWO,MAAM,OAAO,CAACC,SAAQ,UAAU;AACrC,QAAM,EAAE,GAAG,MAAM,GAAGC,MAAM,IAAGD;AAC7B,MAAI,UAAU;AACd,UAAQ,OAAO,OAAK;AAAA,IAClB,KAAK;AACH,UAAI,UAAU,MAAM;AAClB,SAACC,SAAQ,MAAM,YAAaD,QAAO,IAAI,MAAM,SAAW;AACxD;AAAA,MACR;AAAA,IACI,KAAK;AACH,gBAAU;AAAA,IACZ;AACE,WAAK,OAAO,UAAU,KAAK;AAC3B,UAAIC,OAAM;AACR,QAAAD,QAAO,IAAI;AACX,QAAAC,MAAK,YAAY,IAAI;AAAA,MAC7B;AACM;AAAA,EACN;AACE,SAAO;AACT;AAQO,MAAM,YAAY,CAAC,SAAS,UAAU;AAAA,EAC3C;AAAA,EAAS;AAAA,EAAO,SAAS,OAAO,UAAU;AAC5C;AAQO,MAAM,OAAO,CAAC,SAAS,UAAU;AACtC,QAAM,EAAE,QAAO,IAAK;AACpB,aAAW,OAAO,OAAO;AACvB,QAAI,MAAM,GAAG,KAAK,KAAM,QAAO,QAAQ,GAAG;AAAA,QACrC,SAAQ,GAAG,IAAI,MAAM,GAAG;AAAA,EACjC;AACE,SAAO;AACT;AASO,MAAM,SAAS,CAACP,MAAK,OAAO,SAAUA,KAAI,IAAI,IAAI;AASlD,MAAM,MAAM,CAAC,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,KAAK,MAAM,CAAC,CAAC;AAS1E,MAAM,cAAc,CAAC,SAAS,OAAO,SAC1C,SAAS,QACN,gBAAgB,SAAS,IAAI,GAAG,SACjC,OAAO,SAAS,OAAO,IAAI;AASxB,MAAM,MAAM,CAAC,SAAS,WAC1B,OAAO,UAAU,aAChB,MAAM,OAAO,IAAK,MAAM,UAAU,SACpC;AAUF,MAAM,UAAU,CAAC,SAAS,OAAO,UAC9B,SAAS,OACR,gBAAgB,SAAS,IAAI,IAC7B,aAAa,SAAS,MAAM,KAAK,GACnC;AASK,MAAM,QAAQ,CAAC,SAAS,UAC7B,SAAS,OACP,YAAY,SAAS,OAAO,OAAO,IACnC,OAAO,QAAQ,OAAO,OAAO,SAAS;AAUnC,MAAM,SAAS,CAAC,SAAS,OAAO,UACrC,QAAQ,gBAAgB,KAAK,MAAM,CAAC,GAAG,KAAK,GAC5C;AAUK,MAAM,QAAQ,CAAC,MAAM,OAAO,SAAS;AAE1C,QAAM,EAAE,OAAM,IAAK;AACnB,OAAK,OAAO,IAAI,MAAM;AACtB,MAAI;AACF,WAAO,SAAS,KAAK,YAAY,MAAM,OAAO,cAAc,IAAI;AAElE,UAAQ,KAAK,QAAM;AAAA,IACjB,KAAK;AACH,WAAK,CAAC,EAAE,OAAQ;AAAA,IAClB,KAAK;AACH;AAAA,IACF;AACEG;AAAAA,QACE,aAAa,KAAK,CAAC,GAAG,CAAC;AAAA,QACvB,aAAa,KAAK,GAAG,EAAE,GAAG,EAAE;AAAA,QAC5B;AAAA,MACD;AACD;AAAA,EACN;AAEE,SAAO;AACT;AAEO,MAAM,OAAO,oBAAI,IAAI;AAAA,EAC1B,CAAC,QAAQ,IAAI;AAAA,EACb,CAAC,SAAS,SAAS;AAAA,EACnB,CAAC,QAAQ,IAAI;AAAA,EACb,CAAC,OAAO,GAAG;AAAA,EACX,CAAC,SAAS,KAAK;AACjB,CAAC;AAQM,MAAM,YAAY,CAAC,SAAS,MAAMK,SAAQ;AP3OjD;AO4OE,UAAQ,KAAK,CAAC,GAAC;AAAA,IACb,KAAK;AAAK,aAAO;AAAA,IACjB,KAAK;AAAK,aAAO;AAAA,IACjB,KAAK;AAAK,aAAO;AAAA,IACjB;AAAS,aACPA,QAAQ,qBAAqB,UAC1B,SAAS,QAAQ,MAAM,UACvB,KAAK,IAAI,IAAI,MACZ,QAAQ,UACL,KAAK,WAAW,IAAI,IACnB,WACC,SAAI,SAAS,IAAI,MAAjB,mBAAoB,OAAM,cAAc,UAE3C;AAAA,EAIZ;AACA;AAQO,MAAM,OAAO,CAAC,SAAS,WAC3B,QAAQ,cAAc,SAAS,OAAO,KAAK,OAC5C;AC9PK,MAAM,MAAM,CAAC,GAAG,GAAG,OAAO,EAAE,GAAG,GAAG;AAElC,MAAM,KAAK,CAAC,GAAG,OAAO,EAAE,GAAG,EAAC;AAc5B,MAAM,SAAS,CAAC,GAAG,GAAG,GAAG,OAAO,EAAE,GAAG,OAAO,GAAG,GAAG,GAAG,EAAC;AAmBtD,MAAMC,UAAQ,MAAM,IAAI,MAAM,MAAM,KAAK;ACtChD,MAAA,WAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMb,CAACC,WAAU,WAAW;AACpB,UAAM,EAAE,GAAG,UAAU,GAAG,SAAS,GAAGC,YAAW,MAAMD,WAAU,MAAM;AACrE,UAAM,OAAO,SAAS,WAAW,UAAU,IAAI;AAE/C,QAAI,UAAU;AACd,QAAI,YAAY,OAAO;AACrB,gBAAU,CAAE;AACZ,eAASL,UAAS,MAAM,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACtD,cAAM,EAAE,GAAG,MAAM,GAAG,QAAQ,GAAG,KAAI,IAAK,QAAQ,CAAC;AACjD,cAAM,OAAO,SAAS,OAAOA,WAAWA,WAAU,KAAK,MAAO,OAAO;AACrE,gBAAQ,CAAC,IAAI;AAAA,UACX;AAAA,UACA;AAAA,UACA;AAAA,UACA,WAAW,QAAQ,CAAE,IAAI,WAAW,OAAOI,QAAK,IAAK;AAAA,QACtD;AAAA,MACT;AAAA,IACA;AACI,WAAO;AAAA,MACLE,UAAS,KAAK,aAAa,IAAI,mBAAmB,IAAI;AAAA,MACtD;AAAA,IACD;AAAA,EACL;AAAA;ACnCO,MAAM,gBAAgB;AACtB,MAAM,gBAAgB;ACC7B,MAAM,WAAW;AACjB,MAAM,aAAa;AACnB,MAAM,QAAQ;AAad,MAAA,WAAe,CAACD,WAAUE,SAAQ,QAAQ;AACxC,MAAI,IAAI;AACR,SAAOF,UACJ,KAAK,GAAM,EACX,KAAI,EACJ;AAAA,IACC;AAAA,IACA,CAAC,GAAG,MAAM,OAAO,gBAAgB,IAC7B,IACD,GACC,MAAM,QAAQ,YAAY,QAAW,EAAE,QAAO,CAC/C,GACC,cACG,OAAO,cAAc,KAAK,IAAI,IAAK,OAAO,MAAM,IAAI,KACnD,EACd;AAAA,EACA,EACK;AAAA,IACC;AAAA,IACA,CAAAH,UAAQA,UAAS,MAAS,OAAOK,UAAS,GAAG,QAASA,UAAS;AAAA,EACrE;AAEA;ACrCA,IAAI,WAAW,SAAS,cAAc,UAAU,GAAG,KAAK;AAOxD,MAAA,gBAAe,CAACC,OAAM,QAAQ;AAC5B,MAAI,KAAK;AACP,QAAI,CAAC,KAAK;AACR,YAAM,SAAS,gBAAgB,eAAe,KAAK;AACnD,cAAQ,SAAU;AAClB,YAAM,mBAAmB,GAAG;AAAA,IAClC;AACI,WAAO,MAAM,yBAAyBA,KAAI;AAAA,EAC9C;AACE,WAAS,YAAYA;AACrB,QAAM,EAAE,QAAO,IAAK;AACpB,aAAW,SAAS,UAAU,KAAK;AACnC,SAAO;AACT;ACCA,MAAM,aAAa,UAAQ;AACzB,QAAM,OAAO,CAAE;AACf,MAAI;AACJ,SAAQ,aAAa,KAAK,YAAa;AACrC,SAAK,KAAK,KAAK,QAAQ,KAAK,WAAW,YAAY,IAAI,CAAC;AACxD,WAAO;AAAA,EACX;AACE,SAAO;AACT;AAEA,MAAM,WAAW,MAAM,SAAS,eAAe,EAAE;AAOjD,MAAM,UAAU,CAACH,WAAU,QAAQ,QAAQ;AACzC,QAAM,UAAU,cAAcI,SAAOJ,WAAU,QAAQ,GAAG,GAAG,GAAG;AAChE,QAAM,EAAE,OAAM,IAAKA;AACnB,MAAI,UAAU;AACd,MAAI,SAAS,GAAG;AACd,UAAM,UAAU,CAAE;AAClB,UAAM,KAAK,SAAS,iBAAiB,SAAS,IAAI,GAAG;AACrD,QAAI,IAAI,GAAG,SAAS,GAAG,MAAM,GAAG,GAAG;AACnC,cAAU,CAAE;AACZ,WAAO,IAAI,QAAQ;AACjB,YAAM,OAAO,GAAG,SAAU;AAE1B,UAAI,KAAK,aAAa,cAAc;AAClC,YAAI,KAAK,SAAS,QAAQ;AAExB,gBAAM,SAAS,QAAQ,OAAO,IAAI,CAAC,CAAC,IAAI,QAAQ;AAChD,cAAI,WAAW,KAAM,SAAQ,KAAK,IAAI;AACtC,kBAAQ,KAAK,IAAI,WAAW,IAAI,GAAG,QAAQ,IAAI,CAAC;AAChD,mBAAS,GAAG,MAAM,GAAG,GAAG;AAAA,QAClC;AAAA,MACA,OACW;AACH,YAAI;AAEJ,eAAO,KAAK,aAAa,MAAM,GAAG;AAChC,cAAI,CAAC,KAAM,QAAO,WAAW,IAAI;AACjC,gBAAM,OAAO,KAAK,aAAa,MAAM;AACrC,kBAAQ,KAAK,IAAI,MAAM,UAAU,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC;AACxD,0BAAgB,MAAM,MAAM;AAC5B,mBAAS,GAAG,MAAM,GAAG,GAAG;AAAA,QAClC;AAEQ,YACE,CAAC,OACD,cAAc,KAAK,KAAK,SAAS,KACjC,KAAK,YAAY,KAAI,MAAO,OAAO,MAAM,OACzC;AACA,kBAAQ,KAAK,IAAI,QAAQ,WAAW,IAAI,GAAG,MAAM,IAAI,CAAC;AACtD,mBAAS,GAAG,MAAM,GAAG,GAAG;AAAA,QAClC;AAAA,MACA;AAAA,IACA;AAEI,SAAK,IAAI,GAAG,IAAI,QAAQ,QAAQ;AAC9B,cAAQ,CAAC,EAAE,YAAY,SAAQ,CAAE;AAAA,EACvC;AAGE,QAAM,EAAE,WAAU,IAAK;AACvB,MAAI,EAAE,QAAQ,IAAG,IAAK;AAItB,MAAI,MAAM,GAAG;AACX,UAAM;AACN,YAAQ,YAAY,UAAU;AAAA,EAClC,WAGI,QAAQ;AAAA;AAAA,EAGR,WAAW,KACX,WAAW,CAAC,EAAE,aAAa,cAC3B;AAEA,UAAM;AAAA,EACV;AAEE,SAAO,IAAI,OAAOA,WAAU,IAAI,SAAS,SAAS,QAAQ,CAAC,CAAC;AAC9D;AAGA,MAAM,QAAQ,oBAAI;AAClB,MAAM,SAAS;AAMf,MAAe,SAAA,SAAO,CAACA,WAAU,WAAW,MAAM,IAAIA,SAAQ,KAAK,QAAQA,WAAU,QAAQ,GAAG;ACnHhG,MAAM,aAAaZ,SAAO,OAAO,KAAK,CAAC;AACvC,MAAM,YAAYA,SAAO,OAAO,IAAI,CAAC;AAOrC,MAAM,SAAS,CAAC,MAAM,EAAE,GAAG,GAAG,EAAC,MAAO;AACpC,MAAI,KAAK,MAAM,GAAG;AAChB,UAAM,EAAE,GAAG,OAAO,IAAI,YAAY,YAAY,GAAG,CAAC;AAClD,SAAK,IAAI;AACT,SAAK,IAAI;AACT,SAAK,IAAI;AAAA,EACb;AACE,WAAS,EAAE,MAAM,MAAM,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAC/C,UAAM,QAAQ,EAAE,CAAC;AACjB,UAAMQ,UAAS,EAAE,CAAC;AAClB,YAAQA,QAAO,GAAC;AAAA,MACd,KAAK;AACH,QAAAA,QAAO,IAAI;AAAA,UACTA,QAAO;AAAA,UACP,aAAaA,QAAO,GAAG,KAAK;AAAA,UAC5BA,QAAO;AAAA,QACR;AACD;AAAA,MACF,KAAK;AACH,cAAMD,WAAU,iBAAiB,OAC/B,OAAOC,QAAO,MAAMA,QAAO,IAAIG,QAAK,IAAK,KAAK,KAC7CH,QAAO,IAAI,MAAM;AAEpB,YAAID,aAAYC,QAAO;AACrB,UAAAA,QAAO,IAAI,KAAKA,SAAQD,QAAO;AACjC;AAAA,MACF;AACE,YAAI,UAAUC,QAAO;AACnB,UAAAA,QAAO,IAAIA,QAAO,EAAEA,QAAO,GAAG,OAAOA,QAAO,GAAGA,QAAO,CAAC;AACzD;AAAA,IACR;AAAA,EACA;AACE,SAAO,KAAK;AACd;AAOA,MAAM,eAAe,CAAC,OAAO,WAAW;AACtC,MAAI,IAAI,GAAG,EAAE,OAAQ,IAAG;AACxB,MAAI,SAAS,MAAM,OAAQ,OAAM,OAAO,MAAM;AAC9C,SAAO,IAAI,QAAQ,KAAK;AACtB,UAAM,QAAQ,OAAO,CAAC;AACtB,QAAI,iBAAiB;AACnB,aAAO,CAAC,IAAI,OAAO,MAAM,CAAC,MAAM,MAAM,CAAC,IAAIG,QAAO,IAAG,KAAK;AAAA,QACvD,OAAM,CAAC,IAAI;AAAA,EACpB;AACE,SAAO;AACT;AASO,MAAM,KAAK;AAAA,EAChB,YAAYD,MAAKE,WAAU,QAAQ;AACjC,SAAK,IAAIF;AACT,SAAK,IAAIE;AACT,SAAK,IAAI;AAAA,EACb;AAAA,EACE,MAAM,OAAOD,WAAS;AACpB,WAAO,OAAO,MAAM,IAAI;AAAA,EAC5B;AACA;ACjFA;AAQA,MAAM,MAAM,CAAAD,SAAO,CAACE,cAAa,WAAW,IAAI,KAAKF,MAAKE,WAAU,MAAM;AAG9D,MAAC,OAAO,IAAI,KAAK;ACN7B,MAAM,QAAQ,oBAAI;AAUlB,MAAA,WAAe,CAAC,OAAO,MAAM,UAAU;AACrC,QAAM,OAAO,MAAM,IAAI,KAAK,KAAK,IAAI,OAAO,OAAOD,SAAO;AAC1D,QAAM,EAAE,EAAC,IAAK;AACd,QAAMF,QAAwD;AAC9D,QAAM,OAAOA,iBAAgB,OAAOA,MAAK,MAAM,IAAI,IAAIA;AACvD,MAAI,MAAM;AACR,UAAM,iBAAiB,KAAK,IAAI,MAAM,SAAS;AACjD,SAAO;AACT;ACrBA,MAAM,WAAW,IAAI;AAAA,EACnB,CAAC,CAAC,oBAAoB,MAAM,KAAK,MAAM;AAErC,QAAI,MAAO,SAAQ,MAAM,KAAK,OAAO,IAAI,CAAC,IAAI,oBAAoB,WAAW;AAC7E,uBAAmB,IAAI;AAAA,EAC3B;AACA;AAEA,MAAM,cAAc,uBAAO,OAAO,IAAI;AAiB/B,MAAM,SAAS,CACpB,MACA,oBACA,EAAE,OAAO,SAAS,QAAQ,GAAG,QAAQ,SAAS,gBAC3C;AAIH,QAAM,SAAS,KAAK,IAAI,MAAM,MAAM,WAAW,WAAW;AAC1D,QAAM,OAAO,CAAC,QAAQ,CAAC,oBAAoB,MAAM,CAAC,CAAC,KAAK,CAAC;AACzD,MAAI,UAAU,MAAO,MAAK,KAAK,KAAK;AAGpC,WAAS,SAAS,GAAG,IAAI;AACzB,SAAO;AACT;AAOO,MAAM,OAAO,WAAS,SAAS,WAAW,KAAK;AC1CtD,MAAM,UAAU,oBAAI;AAMpB,MAAM,OAAO,aAAW,QAAS;AAEjC,IAAI,SAAS;AAMN,MAAM,SAAS,CAAAR,YAAU;AAU9B,SAAO,CAAC,OAAO,SAAS;AACtB,aAAS,OAAO,SAAS;AACzB,WAAO,KAAK;AAEZ,QAAI,OAAQ,QAAOgB,SAAO,OAAO,IAAW;AAC5C,aAAS;AAET,UAAM,KAAK,IAAI,QAAQ,KAAK;AAC5B,UAAM,UAAUhB,QAAO,MAAM;AAAEgB,eAAO,GAAG,MAAO,GAAE,KAAa,CAAA;AAAA,KAAG;AAClE,YAAQ,IAAI,OAAO,OAAO;AAC1B,WAAO,OAAO,SAAS,MAAM,EAAE,QAAQ,MAAK,CAAE;AAAA,EAC/C;AACH;AAMO,MAAM,SAAS,WAAS;AAC7B,QAAM,UAAU,QAAQ,IAAI,KAAK;AACjC,MAAI,SAAS;AACX,QAAI,OAAQ,SAAQ,OAAO,KAAK;AAChC,SAAK,OAAO;AACZ,YAAS;AAAA,EACb;AACA;ACpDA,MAAM,SAASC,OAAS,MAAM;AAMlB,MAAC,QAAQ,SAAS,aAAa,eAAe,SAAS,aAAa;AAIpE,MAAC,SAAS,IAAI,MAAO,SAAU,QAAQ,MAAM,cAAc,GAAG,CAAC;AAG/D,MAAC,gBAAgB;AAAA,EAC3B,OAAO,CAAE;AAAA,EACT,SAAS,CAAC,KAAK,UAAU,cAAc,MAAM,GAAG,IAAI;AAAA,EACpD,SAAS,CAAC,QAAQ,cAAc,MAAM,GAAG,KAAK;AAAA,EAC9C,YAAY,CAAC,QAAQ,OAAO,cAAc,GAAG;AAAA,EAC7C,OAAO,MAAM,cAAc,QAAQ,CAAA;AACrC;AAGO,eAAe,2BAA2B;AAC/C,QAAM,IAAI,QAAQ,qBAAqB;AACvC,SAAO;AACT;AAGA,MAAM,WAAY,uBAAM;AACtB,QAAMC,aAAY,oBAAI,IAAK;AAE3B,SAAO;AAAA,IACL,UAAU,KAAK,UAAU;AACvB,UAAI,CAACA,WAAU,IAAI,GAAG,EAAG,CAAAA,WAAU,IAAI,KAAK,oBAAI,KAAK;AACrD,MAAAA,WAAU,IAAI,GAAG,EAAE,IAAI,QAAQ;AAC/B,aAAO,MAAMA,WAAU,IAAI,GAAG,EAAE,OAAO,QAAQ;AAAA,IAChD;AAAA,IACD,QAAQ,KAAK,OAAO;AAClB,UAAIA,WAAU,IAAI,GAAG,GAAG;AACtB,mBAAW,MAAMA,WAAU,IAAI,GAAG,EAAG,IAAG,KAAK;AAC7C,eAAO;AAAA,MACf,OAAa;AACL;AAAA,MACR;AAAA,IACA;AAAA,EACG;AACH,GAAI;AAGG,MAAM,sBAAsB,YAAY;AAAA,EAW7C,cAAc;AACZ,UAAO;AAXT,+BAAS,CAAE;AACX,iCAAW,CAAE;AACb,uCAAiB,CAAE;AACnB,uCAAiB;AAEjB,mCAAU;AAEV,6BAAI,CAAC,MAAM,SAAS,cAAc,CAAC;AACnC,8BAAK,CAAC,MAAM,SAAS,iBAAiB,CAAC;AAIrC,SAAK,eAAgB;AAAA,EACzB;AAAA,EAEE,iBAAiB;AAAA,EAEnB;AAAA,EAEE,qBAAqB,OAAO,MAAM;AnBzEpC;AmB0EI,UAAM,UAAU,CAAE;AAClB,UAAM,YAAY,KAAK,iBAAiB,gBAAgB;AACxD,eAAW,QAAQ,WAAW;AAC5B,YAAM,OAAO,KAAK,aAAa,MAAM;AACrC,YAAM,WAAW,KAAK,QAAQ,UAAU,IAAI;AAC5C,UAAI,CAAC,oBAAoB,MAAM,EAAE,WAAS,UAAK,aAAa,MAAM,MAAxB,mBAA2B,kBAAiB,EAAE,GAAI;AAC1F,cAAM,aAAa,SAAS;AAC5B,gBAAQ,IAAI,IAAI,KAAK,cAAc,UAAU;AAAA,MACrD,OAAa;AACL,gBAAQ,IAAI,IAAI;AAAA,MACxB;AACM,WAAK,OAAM;AAAA,IACjB;AAEI,WAAO;AAAA,EACX;AAAA,EAEE,KAAK,MAAM;AACT,WAAO,KAAK,MAAM,IAAI,KAAK,KAAK,eAAe,IAAI,KAAK;AAAA,EAC5D;AAAA,EAEE,cAAc,MAAM;AAChB,QAAI;AACF,aAAO,KAAK,MAAM,IAAI;AAAA,IACvB,SAAQ,GAAG;AACV,aAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,uDAAuD,CAAC;AAC1G,aAAO;AAAA,IACf;AAAA,EACA;AAAA,EAEE,oBAAoB;AAElB,SAAK,IAAI,KAAK,MAAM;AAGpB,QAAI,OAAO;AACT,UAAI,CAAC,OAAO,YAAY;AACtB,eAAO,aAAa,EAAE,WAAW,oBAAI,IAAG,EAAI;AAAA,MACpD;AACM,aAAO,WAAW,UAAU,IAAI,IAAI;AAAA,IAC1C;AAGI,SAAK,KAAM;AAGX,QAAI,OAAO,KAAK,aAAa,YAAY;AACvC,UAAI;AACF,eAAO,MAAM,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,MACtC,SAAQ,GAAG;AACV,cAAM,QAAQ,MAAM,kRAAkR,CAAC;AAAA,MAC/S;AAAA,IACA;AAAA,EACA;AAAA,EAEE,uBAAuB;AnBjIzB;AmBkII,eAAW,SAAS,mBAAK,gBAAgB,OAAO;AAChD,uBAAK,gBAAiB,CAAE;AAExB,iBAAO,eAAP,mBAAmB,UAAU,OAAO;AAEpC,eAAW,EAAE,OAAO,QAAO,KAAM,mBAAK,WAAU;AAC9C,aAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,yBAAyB,KAAK,EAAE;AAClF,UAAI,OAAO,YAAY,WAAY,SAAS;AAAA,IAClD;AACI,uBAAK,UAAW,CAAE;AAAA,EACtB;AAAA,EAEE,OAAO;AAAA,EAET;AAAA,EAEE,OAAO,GAAG;AACR,QAAI,MAAM,OAAQ,QAAO;AACzB,QAAI,MAAM,QAAS,QAAO;AAC1B,QAAI,CAAC,MAAM,WAAW,CAAC,CAAC,KAAK,SAAS,CAAC,EAAG,QAAO,OAAO,CAAC;AACzD,WAAO;AAAA,EACX;AAAA,EAEE,MAAM,KAAK,cAAc,UAAU,KAAK,SAAS;AAC/C,QAAI,EAAE,OAAO,mBAAK,UAAS;AACzB,UAAI;AAEJ,UAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,gBAAQ,KAAK,OAAO,KAAK,aAAa,GAAG,CAAC,KAAK,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,GAAG,MAAM;AACpG,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,YAAY,GAAG,kCAAkC,KAAK;AAAA,MACzG,WAAU,QAAQ,QAAQ,GAAG,MAAM,MAAM;AACxC,gBAAQ,KAAK,OAAO,QAAQ,QAAQ,GAAG,CAAC;AACxC,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,YAAY,GAAG,6BAA6B,KAAK;AAAA,MAC3G,OAAa;AACL,gBAAQ;AACR,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,YAAY,GAAG,kCAAkC,KAAK;AAAA,MAChH;AAEM,YAAMC,KAAI,OAAO,KAAK;AACtB,yBAAK,QAAO,GAAG,IAAIA;AAEnB,YAAM,UAAU,OAAO,MAAM;AAC3B,eAAO,IAAI,KAAK,QAAQ,YAAa,CAAA,OAAO,KAAK,CAAC,YAAY,GAAG,eAAeA,GAAE,KAAK;AACvF,aAAK,iBAAiB,KAAKA,GAAE,KAAK,KAAK,OAAO,wBAAwB,GAAG,MAAMA,GAAE,KAAK;AACtF,gBAAQ,QAAQ,KAAKA,GAAE,KAAK,KAAK,OAAO,sBAAsB,GAAG,MAAMA,GAAE,KAAK;AAAA,MACtF,CAAO;AAED,yBAAK,UAAS,KAAK,EAAE,OAAO,SAAS,GAAG,IAAI,SAAS;AAAA,IAC3D;AAEI,UAAM,IAAI,mBAAK,QAAO,GAAG;AACzB,WAAO,CAAC,MAAM,EAAE,OAAO,OAAK,EAAE,QAAQ,CAAC;AAAA,EAC3C;AAAA,EAEE,SAAS,KAAK,cAAc,UAAU,KAAK,SAAS;AAClD,QAAI;AACJ,UAAM,gBAAgB,OAAO,mBAAK;AAClC,QAAI,CAAC,eAAe;AAClB,UAAI;AACJ,UAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,gBAAQ,KAAK,OAAO,KAAK,aAAa,GAAG,CAAC,KAAK,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,GAAG,MAAM;AACpG,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,eAAe,GAAG,kCAAkC,KAAK;AAAA,MAC5G,WAAU,QAAQ,QAAQ,GAAG,MAAM,MAAM;AACxC,gBAAQ,KAAK,OAAO,QAAQ,QAAQ,GAAG,CAAC;AACxC,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,eAAe,GAAG,6BAA6B,KAAK;AAAA,MAC9G,OAAa;AACL,gBAAQ;AACR,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,eAAe,GAAG,kCAAkC,KAAK;AAAA,MACnH;AACM,UAAI,OAAO,KAAK;AAChB,yBAAK,QAAO,GAAG,IAAI;AAAA,IACzB,OAAW;AACL,UAAI,mBAAK,QAAO,GAAG;AAAA,IACzB;AAEI,UAAM,cAAc,SAAS,UAAU,KAAK,YAAU;AACpD,aAAO,IAAI,KAAK,EAAE,UAAU,GAAG,MAAM,MAAM;AAC3C,UAAI,EAAE,UAAU,OAAQ,GAAE,QAAQ;AAAA,IACxC,CAAK;AACD,uBAAK,gBAAe,KAAK,WAAW;AAEpC,UAAM,YAAY,mBAAK,UAAS,KAAK,OAAK,EAAE,UAAU,OAAO,GAAG,EAAE;AAClE,QAAI,CAAC,WAAW;AACd,YAAM,UAAU,OAAO,MAAM;AAC3B,eAAO,IAAI,KAAK,QAAQ,YAAa,CAAA,OAAO,KAAK,CAAC,eAAe,GAAG,cAAc,EAAE,KAAK;AACzF,iBAAS,QAAQ,KAAK,EAAE,KAAK,KAAK,OAAO,QAAQ,GAAG,MAAM,EAAE,KAAK;AACjE,aAAK,iBAAiB,KAAK,EAAE,KAAK,KAAK,OAAO,wBAAwB,GAAG,MAAM,EAAE,KAAK;AACtF,gBAAQ,QAAQ,KAAK,EAAE,KAAK,KAAK,OAAO,sBAAsB,GAAG,MAAM,EAAE,KAAK;AAAA,MACtF,CAAO;AACD,yBAAK,UAAS,KAAK,EAAE,OAAO,OAAO,GAAG,IAAI,SAAS;AAAA,IACzD;AAEI,WAAO,CAAC,MAAM,EAAE,OAAO,OAAK,EAAE,QAAQ,CAAC;AAAA,EAC3C;AAAA,EAEE,YAAY,cAAc;AACxB,UAAM,IAAI,OAAO,YAAY;AAC7B,WAAO,CAAC,MAAM,EAAE,OAAO,OAAK,EAAE,QAAQ,CAAC;AAAA,EAC3C;AAAA,EAEE,iBAAiB,KAAK,KAAK;AACzB,QAAI,QAAQ,KAAK,YAAY,sBAAsB,CAAE;AACrD,QAAI,MAAM,SAAS,GAAG,KAAK,QAAQ,MAAM;AACvC,aAAO,KAAK,aAAa,KAAK,GAAG;AAAA,IACvC,OAAW;AACL;AAAA,IACN;AAAA,EACA;AAAA,EAEE,yBAAyB,MAAM,UAAU,UAAU;AACjD,QAAI,aAAa,SAAU;AAC3B,WAAO,IAAI,KAAK,QAAQ,YAAa,CAAA,OAAO,KAAK,CAAC,MAAM,IAAI,uBAAuB,UAAU,KAAK,QAAQ;AAE1G,UAAM,UAAU,KAAK,OAAO,QAAQ,KAAK,KAAK,aAAa,IAAI,KAAK,KAAK,aAAa,IAAI,MAAM;AAChG,QAAI,QAAQ,mBAAK,WAAU,mBAAK,QAAO,IAAI,EAAE,UAAU,SAAS;AAC9D,yBAAK,QAAO,IAAI,EAAE,QAAQ;AAC1B,eAAS,QAAQ,MAAM,OAAO;AAAA,IACpC;AAAA,EACA;AAAA,EAEE,OAAO,IAAI,aAAa;AACtB,QAAI,QAAQ;AACZ,QAAI,OAAO;AAEX,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,aAAO;AAAA,IACb,WAAe,OAAO,gBAAgB,UAAU;AAC1C,cAAQ;AAAA,IACd;AAEI,UAAM,MAAM,MAAM;AAChB,aAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,uBAAuB,KAAK,EAAE;AAChF,YAAM,SAAS,GAAI;AACnB,aAAO,OAAO,WAAW,aAAa,SAAS;AAAA,IAChD;AAED,UAAM,UAAU,OACZ,OAAO,MAAM;AACX,WAAK,IAAI,OAAK,EAAG,CAAA;AACjB,aAAO,IAAK;AAAA,IACb,CAAA,IACD,OAAO,GAAG;AAEd,uBAAK,UAAS,KAAK,EAAE,OAAO,QAAO,CAAE;AAAA,EACzC;AAAA,EAEE,aAAa;AACX,uBAAK,UAAS,QAAQ,CAAAnB,YAAU;AAC9B,YAAM,YACJA,QAAO,KAAK,WAAWA,QAAO,KAAK,UACnCA,QAAO,KAAK,KAAK,CAAC,KAAK,MAAM,IAAG,MAAOA,QAAO,KAAK,CAAC,CAAC;AAEvD,UAAI,WAAW;AACb,YAAI,OAAOA,QAAO,YAAY,YAAY;AACxC,UAAAA,QAAO,QAAS;AAAA,QAC1B;AAEQ,cAAM,SAASA,QAAO,GAAI;AAC1B,QAAAA,QAAO,UAAU,OAAO,WAAW,aAAa,SAAS;AACzD,QAAAA,QAAO,OAAOA,QAAO,KAAK,IAAI,SAAO,KAAK;AAAA,MAClD;AAAA,IACA,CAAK;AAAA,EACL;AAAA,EAEE,SAAS,WAAW,KAAK;AACvB,QAAI,OAAO,cAAc,YAAY;AACnC,YAAM,IAAI,MAAM,yCAAyC,OAAO,SAAS,EAAE;AAAA,IACjF;AAEI,QAAI,EAAE,OAAO,mBAAK,UAAS;AACzB,YAAMoB,KAAI,SAAS,SAAS;AAC5B,yBAAK,QAAO,GAAG,IAAIA;AAEnB,YAAM,UAAU,OAAO,MAAM;AAC3B,cAAM,MAAMA,GAAE;AACd,eAAO,IAAI,KAAK,QAAQ,YAAW,CAAE,OAAO,KAAK,CAAC,MAAM,GAAG,uBAAuB,GAAG;AAAA,MAC7F,CAAO;AAED,yBAAK,UAAS,KAAK,EAAE,OAAO,YAAY,GAAG,IAAI,SAAS;AAAA,IAC9D;AAEI,UAAM,IAAI,mBAAK,QAAO,GAAG;AACzB,WAAO,MAAM,EAAE;AAAA,EACnB;AAAA,EAEE,eAAeC,OAAM,QAAQ;AAC3B,SAAK,OAAO,MAAM;AAChB,YAAM,MAAM,OAAQ;AACpB,UAAI,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,QAAW;AACtD,aAAK,gBAAgBA,KAAI;AACzB,eAAO,IAAI,KAAK,QAAQ,YAAa,CAAA,OAAO,KAAK,CAAC,gBAAgBA,KAAI,WAAW;AAAA,MACzF,OAAa;AACL,aAAK,aAAaA,OAAM,EAAE;AAC1B,eAAO,IAAI,KAAK,QAAQ,YAAa,CAAA,OAAO,KAAK,CAAC,gBAAgBA,KAAI,SAAS;AAAA,MACvF;AAAA,IACA,GAAO,CAAC,MAAM,CAAC;AAAA,EACf;AAAA,EAEE,eAAe,UAAU,QAAQ;AAC/B,SAAK,OAAO,MAAM;AAChB,WAAK,aAAa,UAAU,QAAQ;AAAA,IAC1C,GAAO,CAAC,MAAM,OAAM,CAAE,CAAC;AAAA,EACvB;AAEA;AAxRE;AACA;AACA;AACA;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}